"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PdfTools = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const pdf_lib_1 = require("pdf-lib");
const pdf_parse_1 = __importDefault(require("pdf-parse"));
var Operation;
(function (Operation) {
    Operation["AddImage"] = "addImage";
    Operation["Watermark"] = "watermark";
    Operation["Delete"] = "delete";
    Operation["ExtractPages"] = "extractPages";
    Operation["ExtractText"] = "extractText";
    Operation["Merge"] = "merge";
    Operation["Metadata"] = "metadata";
    Operation["Reorder"] = "reorder";
    Operation["Rotate"] = "rotate";
    Operation["Split"] = "split";
})(Operation || (Operation = {}));
class PdfOperations {
    static findBinaryByMimeType(items, mimeType) {
        for (const item of items) {
            if (!item.binary)
                continue;
            for (const [_, binary] of Object.entries(item.binary)) {
                if (binary.mimeType === mimeType) {
                    return {
                        buffer: Buffer.from(binary.data, 'base64'),
                        mimeType: binary.mimeType,
                        fileName: binary.fileName
                    };
                }
            }
        }
        return undefined;
    }
    static findAllBinariesByMimeType(items, mimeType) {
        const results = [];
        for (const item of items) {
            if (!item.binary)
                continue;
            for (const [_, binary] of Object.entries(item.binary)) {
                if (binary.mimeType === mimeType) {
                    results.push({
                        buffer: Buffer.from(binary.data, 'base64'),
                        mimeType: binary.mimeType,
                        fileName: binary.fileName
                    });
                }
            }
        }
        return results;
    }
    static findPdfAndImage(items) {
        const result = {};
        result.pdf = this.findBinaryByMimeType(items, 'application/pdf');
        result.image = this.findBinaryByMimeType(items, 'image/png') ||
            this.findBinaryByMimeType(items, 'image/jpeg');
        return result;
    }
    static validatePdfBinary(binary, node, itemIndex) {
        if (!binary || binary.mimeType !== 'application/pdf') {
            throw new n8n_workflow_1.NodeOperationError(node, `Le fichier doit être au format PDF (MIME type: application/pdf). Type reçu: ${(binary === null || binary === void 0 ? void 0 : binary.mimeType) || 'aucun'}`, { itemIndex });
        }
        return Buffer.from(binary.data, 'base64');
    }
    static validateImageBinary(binary, node, itemIndex) {
        if (!binary || (binary.mimeType !== 'image/png' && binary.mimeType !== 'image/jpeg')) {
            throw new n8n_workflow_1.NodeOperationError(node, `Le fichier doit être une image PNG ou JPEG. Type reçu: ${(binary === null || binary === void 0 ? void 0 : binary.mimeType) || 'aucun'}`, { itemIndex });
        }
        return Buffer.from(binary.data, 'base64');
    }
    static validatePageSelection(pages, pageCount) {
        const pageNumbers = pages.split(',').map(p => {
            const trimmed = p.trim();
            if (trimmed.includes('-')) {
                const [start, end] = trimmed.split('-').map(n => parseInt(n));
                return Array.from({ length: end - start + 1 }, (_, i) => start + i - 1);
            }
            return parseInt(trimmed) - 1;
        }).flat();
        if (pageNumbers.some(p => p < 0 || p >= pageCount)) {
            throw new n8n_workflow_1.NodeOperationError({ name: 'PDF Tools', type: 'n8n-nodes-base.pdftools' }, `Invalid page numbers. Pages must be between 1 and ${pageCount}`);
        }
        return pageNumbers;
    }
    static ensureMimeType(binary, expectedTypes) {
        if (!expectedTypes.includes(binary.mimeType)) {
            throw new n8n_workflow_1.NodeOperationError({ name: 'PDF Tools', type: 'n8n-nodes-base.pdftools' }, `Type MIME non supporté: ${binary.mimeType}. Types attendus: ${expectedTypes.join(', ')}`);
        }
    }
    static async addImage(pdfBuffer, imageBuffer, imageMimeType, pageTarget = 'all', imageOptions = { x: 50, y: 400, scale: 0.5 }) {
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        const pageCount = pdfDoc.getPageCount();
        const targetPages = this.validatePageSelection(pageTarget, pageCount);
        let image;
        if (imageMimeType === 'image/png') {
            image = await pdfDoc.embedPng(imageBuffer);
        }
        else if (imageMimeType === 'image/jpeg') {
            image = await pdfDoc.embedJpg(imageBuffer);
        }
        else {
            throw new n8n_workflow_1.NodeOperationError({ name: 'PDF Tools', type: 'n8n-nodes-base.pdftools' }, `Format d'image non supporté: ${imageMimeType}. Formats supportés: PNG, JPEG`);
        }
        const { width, height } = image.scale(imageOptions.scale);
        for (const pageIndex of targetPages) {
            const page = pdfDoc.getPage(pageIndex);
            page.drawImage(image, { x: imageOptions.x, y: imageOptions.y, width, height });
        }
        return Buffer.from(await pdfDoc.save());
    }
    static async addWatermark(pdfBuffer, text, pageTarget = 'all', watermarkOptions = { text: '', fontSize: 50, color: '#808080', opacity: 0.3, x: 0, y: 0 }) {
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        const pageCount = pdfDoc.getPageCount();
        const targetPages = pageTarget === 'all'
            ? Array.from({ length: pageCount }, (_, i) => i)
            : this.validatePageSelection(pageTarget, pageCount);
        for (const pageIndex of targetPages) {
            const page = pdfDoc.getPage(pageIndex);
            const { width, height } = page.getSize();
            page.drawText(text, {
                x: width / 2,
                y: height / 2,
                size: watermarkOptions.fontSize,
                opacity: watermarkOptions.opacity,
                color: (0, pdf_lib_1.rgb)(parseInt(watermarkOptions.color.slice(1, 3), 16) / 255, parseInt(watermarkOptions.color.slice(3, 5), 16) / 255, parseInt(watermarkOptions.color.slice(5, 7), 16) / 255),
            });
        }
        return Buffer.from(await pdfDoc.save());
    }
    static async deletePages(pdfBuffer, pages) {
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        const pagesToDelete = this.validatePageSelection(pages, pdfDoc.getPageCount());
        pagesToDelete.sort((a, b) => b - a);
        pagesToDelete.forEach((page) => pdfDoc.removePage(page));
        return Buffer.from(await pdfDoc.save());
    }
    static async reorderPages(pdfBuffer, order) {
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        const pageCount = pdfDoc.getPageCount();
        const newOrder = this.validatePageSelection(order, pageCount);
        const newDoc = await pdf_lib_1.PDFDocument.create();
        for (const index of newOrder) {
            const [copiedPage] = await newDoc.copyPages(pdfDoc, [index]);
            newDoc.addPage(copiedPage);
        }
        return Buffer.from(await newDoc.save());
    }
    static async rotatePages(pdfBuffer, pages, angle) {
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        const pagesToRotate = this.validatePageSelection(pages, pdfDoc.getPageCount());
        pagesToRotate.forEach((pageIndex) => {
            const page = pdfDoc.getPages()[pageIndex];
            const currentRotation = page.getRotation().angle;
            const newRotation = (currentRotation + angle) % 360;
            page.setRotation((0, pdf_lib_1.degrees)(newRotation));
        });
        return Buffer.from(await pdfDoc.save());
    }
    static async splitPDF(pdfBuffer, pages) {
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        const pageCount = pdfDoc.getPageCount();
        const selectedPages = this.validatePageSelection(pages, pageCount);
        const newPdf = await pdf_lib_1.PDFDocument.create();
        for (const pageIndex of selectedPages) {
            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageIndex]);
            newPdf.addPage(copiedPage);
        }
        return Buffer.from(await newPdf.save());
    }
    static async extractPages(pdfBuffer, pages) {
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        const pageCount = pdfDoc.getPageCount();
        const selectedPages = this.validatePageSelection(pages, pageCount);
        const newPdf = await pdf_lib_1.PDFDocument.create();
        for (const pageIndex of selectedPages) {
            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageIndex]);
            newPdf.addPage(copiedPage);
        }
        return Buffer.from(await newPdf.save());
    }
    static async mergePDFs(pdfBuffers) {
        const mergedPdf = await pdf_lib_1.PDFDocument.create();
        for (const pdfBuffer of pdfBuffers) {
            const pdf = await pdf_lib_1.PDFDocument.load(pdfBuffer);
            const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
            copiedPages.forEach((page) => mergedPdf.addPage(page));
        }
        return Buffer.from(await mergedPdf.save());
    }
    static async readMetadata(pdfBuffer) {
        var _a, _b;
        const pdfDoc = await pdf_lib_1.PDFDocument.load(pdfBuffer);
        return {
            title: pdfDoc.getTitle() || '',
            author: pdfDoc.getAuthor() || '',
            subject: pdfDoc.getSubject() || '',
            keywords: pdfDoc.getKeywords() || '',
            creator: pdfDoc.getCreator() || '',
            producer: pdfDoc.getProducer() || '',
            creationDate: ((_a = pdfDoc.getCreationDate()) === null || _a === void 0 ? void 0 : _a.toISOString()) || '',
            modificationDate: ((_b = pdfDoc.getModificationDate()) === null || _b === void 0 ? void 0 : _b.toISOString()) || '',
        };
    }
    static async extractText(pdfBuffer) {
        const data = await (0, pdf_parse_1.default)(pdfBuffer);
        return data.text;
    }
}
class PdfTools {
    constructor() {
        this.description = {
            displayName: 'PDF Tools',
            name: 'pdfTools',
            icon: 'file:pdfTools.svg',
            group: ['transform'],
            version: 1,
            subtitle: '={{$parameter["operation"]}}',
            description: 'Manipulate PDF files with various operations',
            defaults: {
                name: 'PDF Tools',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [],
            properties: [
                {
                    displayName: 'Operation',
                    name: 'operation',
                    type: 'options',
                    noDataExpression: true,
                    default: 'addImage',
                    options: [
                        {
                            name: 'Add Image',
                            value: Operation.AddImage,
                            description: 'Add an image to an existing PDF',
                            action: 'Add an image to a PDF',
                        },
                        {
                            name: 'Add Watermark',
                            value: Operation.Watermark,
                            description: 'Add a text watermark to a PDF',
                            action: 'Add a watermark to a PDF',
                        },
                        {
                            name: 'Delete Pages',
                            value: Operation.Delete,
                            description: 'Delete specific pages from a PDF',
                            action: 'Delete pages from a PDF',
                        },
                        {
                            name: 'Extract Pages',
                            value: Operation.ExtractPages,
                            description: 'Extract specific pages into a new PDF',
                            action: 'Extract pages from a PDF',
                        },
                        {
                            name: 'Extract Text',
                            value: Operation.ExtractText,
                            description: 'Extract text content from a PDF',
                            action: 'Extract text from a PDF',
                        },
                        {
                            name: 'Merge PDFs',
                            value: Operation.Merge,
                            description: 'Merge multiple PDFs into one',
                            action: 'Merge multiple PDF',
                        },
                        {
                            name: 'Read Metadata',
                            value: Operation.Metadata,
                            description: 'Read metadata from a PDF',
                            action: 'Read metadata from a PDF',
                        },
                        {
                            name: 'Reorder Pages',
                            value: Operation.Reorder,
                            description: 'Reorder pages in a PDF',
                            action: 'Reorder pages in a PDF',
                        },
                        {
                            name: 'Rotate Pages',
                            value: Operation.Rotate,
                            description: 'Rotate pages in a PDF',
                            action: 'Rotate pages in a PDF',
                        },
                        {
                            name: 'Split PDF',
                            value: Operation.Split,
                            description: 'Split a PDF into multiple files',
                            action: 'Split a PDF into multiple files',
                        },
                    ],
                },
                {
                    displayName: 'PDF Binary Field',
                    name: 'pdfBinaryName',
                    type: 'string',
                    default: '',
                    description: 'Name of the binary field containing the PDF',
                    displayOptions: {
                        show: {
                            operation: [
                                Operation.AddImage,
                                Operation.Watermark,
                                Operation.Delete,
                                Operation.ExtractPages,
                                Operation.ExtractText,
                                Operation.Metadata,
                                Operation.Reorder,
                                Operation.Rotate,
                                Operation.Split,
                            ],
                        },
                    },
                },
                {
                    displayName: 'Image Binary Field',
                    name: 'imageBinaryName',
                    type: 'string',
                    default: '',
                    description: 'Name of the binary field containing the image (PNG or JPEG)',
                    displayOptions: {
                        show: {
                            operation: [Operation.AddImage],
                        },
                    },
                },
                {
                    displayName: 'PDF Binary Field Names',
                    name: 'pdfBinaryNames',
                    type: 'string',
                    default: '',
                    description: 'Comma-separated list of binary field names containing PDFs to merge',
                    displayOptions: {
                        show: {
                            operation: [Operation.Merge],
                        },
                    },
                    hint: 'Enter the names of the binary fields containing PDFs, separated by commas',
                },
                {
                    displayName: 'New Page Order',
                    name: 'newPageOrder',
                    type: 'string',
                    default: '',
                    description: 'New order of pages (e.g., "3,1,2" to put page 3 first, then page 1, then page 2)',
                    displayOptions: {
                        show: {
                            operation: [Operation.Reorder],
                        },
                    },
                    hint: 'Enter the new page order as comma-separated numbers',
                },
                {
                    displayName: 'Page Target',
                    name: 'pageTarget',
                    type: 'string',
                    default: 'all',
                    description: 'Target pages (e.g., "1", "1,3-5", "all")',
                    displayOptions: {
                        show: {
                            operation: [
                                Operation.AddImage,
                                Operation.Watermark,
                                Operation.Delete,
                                Operation.ExtractPages,
                                Operation.Rotate,
                                Operation.Split,
                            ],
                        },
                    },
                },
                {
                    displayName: 'Watermark Text',
                    name: 'watermarkText',
                    type: 'string',
                    default: '',
                    description: 'Text to use as watermark',
                    displayOptions: {
                        show: {
                            operation: [Operation.Watermark],
                        },
                    },
                },
                {
                    displayName: 'Rotation Angle',
                    name: 'rotationAngle',
                    type: 'number',
                    default: 90,
                    description: 'Rotation angle in degrees (90, 180, 270)',
                    displayOptions: {
                        show: {
                            operation: [Operation.Rotate],
                        },
                    },
                },
                {
                    displayName: 'Image Options',
                    name: 'imageOptions',
                    type: 'collection',
                    default: {},
                    description: 'Options for image placement and scaling',
                    displayOptions: {
                        show: {
                            operation: [Operation.AddImage],
                        },
                    },
                    options: [
                        {
                            displayName: 'X Position',
                            name: 'x',
                            type: 'number',
                            default: 50,
                            description: 'X coordinate for image position',
                        },
                        {
                            displayName: 'Y Position',
                            name: 'y',
                            type: 'number',
                            default: 400,
                            description: 'Y coordinate for image position',
                        },
                        {
                            displayName: 'Scale',
                            name: 'scale',
                            type: 'number',
                            default: 0.5,
                            description: 'Image scale factor',
                        },
                    ],
                },
                {
                    displayName: 'Watermark Options',
                    name: 'watermarkOptions',
                    type: 'collection',
                    default: {},
                    description: 'Options for watermark styling',
                    displayOptions: {
                        show: {
                            operation: [Operation.Watermark],
                        },
                    },
                    options: [
                        {
                            displayName: 'Font Size',
                            name: 'fontSize',
                            type: 'number',
                            default: 50,
                            description: 'Font size for watermark text',
                        },
                        {
                            displayName: 'Color',
                            name: 'color',
                            type: 'color',
                            default: '#808080',
                            description: 'Color of the watermark',
                        },
                        {
                            displayName: 'Opacity',
                            name: 'opacity',
                            type: 'number',
                            default: 0.3,
                            description: 'Opacity of the watermark (0-1)',
                        },
                    ],
                },
                {
                    displayName: 'Pages',
                    name: 'pages',
                    type: 'string',
                    default: 'all',
                    description: 'Pages to extract, split, or rotate (e.g., "1", "1,3-5", "all")',
                    displayOptions: {
                        show: {
                            operation: [
                                Operation.Delete,
                                Operation.ExtractPages,
                                Operation.Rotate,
                                Operation.Split,
                            ],
                        },
                    },
                },
            ],
        };
    }
    async execute() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const items = this.getInputData();
        const returnData = [];
        for (let i = 0; i < items.length; i++) {
            try {
                const operation = this.getNodeParameter('operation', i);
                const binaryFields = this.getNodeParameter('binaryFields', i);
                const options = this.getNodeParameter('options', i);
                let result;
                let pdfBinaryName = 'output';
                console.log(`Starting operation ${operation} on item ${i}`);
                switch (operation) {
                    case Operation.AddImage: {
                        const pdfBinaryName = ((_a = binaryFields.pdfBinaryName) === null || _a === void 0 ? void 0 : _a.pdfBinaryName) || 'output';
                        const imageBinaryName = ((_b = binaryFields.imageBinaryName) === null || _b === void 0 ? void 0 : _b.imageBinaryName) || 'image';
                        const pageTarget = ((_c = options.watermarkOptions) === null || _c === void 0 ? void 0 : _c.pageTarget) || 'all';
                        console.log(`Processing AddImage with PDF: ${pdfBinaryName}, Image: ${imageBinaryName}, Target: ${pageTarget}`);
                        const pdfBinary = (_d = items[i].binary) === null || _d === void 0 ? void 0 : _d[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        const imageBinary = (_e = items[i].binary) === null || _e === void 0 ? void 0 : _e[imageBinaryName];
                        if (!imageBinary) {
                            throw new Error(`No binary data found for ${imageBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        PdfOperations.ensureMimeType(imageBinary, ['image/png', 'image/jpeg']);
                        const imageOptions = this.getNodeParameter('imageOptions.position', i);
                        result = await PdfOperations.addImage(Buffer.from(pdfBinary.data, 'base64'), Buffer.from(imageBinary.data, 'base64'), imageBinary.mimeType, pageTarget, imageOptions);
                        break;
                    }
                    case Operation.Watermark: {
                        const pdfBinaryName = ((_f = binaryFields.pdfBinaryName) === null || _f === void 0 ? void 0 : _f.pdfBinaryName) || 'output';
                        const { watermarkText, pageTarget } = options.watermarkOptions || { watermarkText: '', pageTarget: 'all' };
                        console.log(`Processing Watermark with PDF: ${pdfBinaryName}, Text: ${watermarkText}, Target: ${pageTarget}`);
                        if (!watermarkText) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Le texte du filigrane est requis');
                        }
                        const pdfBinary = (_g = items[i].binary) === null || _g === void 0 ? void 0 : _g[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        const watermarkOptions = this.getNodeParameter('watermarkOptions.style', i);
                        result = await PdfOperations.addWatermark(Buffer.from(pdfBinary.data, 'base64'), watermarkOptions.text, pageTarget, watermarkOptions);
                        break;
                    }
                    case Operation.Delete: {
                        const pdfBinaryName = ((_h = binaryFields.pdfBinaryName) === null || _h === void 0 ? void 0 : _h.pdfBinaryName) || 'output';
                        const pages = (_j = options.pageOptions) === null || _j === void 0 ? void 0 : _j.pages;
                        console.log(`Processing Delete with PDF: ${pdfBinaryName}, Pages: ${pages}`);
                        if (!pages) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Les pages à supprimer sont requises');
                        }
                        const pdfBinary = (_k = items[i].binary) === null || _k === void 0 ? void 0 : _k[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        result = await PdfOperations.deletePages(Buffer.from(pdfBinary.data, 'base64'), pages);
                        break;
                    }
                    case Operation.Merge: {
                        const pdfBinaryNames = (((_l = binaryFields.pdfBinaryNames) === null || _l === void 0 ? void 0 : _l.pdfBinaryNames) || '').split(',').filter(Boolean);
                        console.log(`Processing Merge with PDFs: ${pdfBinaryNames.join(', ')}`);
                        if (pdfBinaryNames.length < 2) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Au moins deux fichiers PDF sont requis pour la fusion');
                        }
                        const pdfBuffers = await Promise.all(pdfBinaryNames.map(async (name) => {
                            var _a;
                            const binary = (_a = items[i].binary) === null || _a === void 0 ? void 0 : _a[name.trim()];
                            if (!binary) {
                                throw new Error(`No binary data found for ${name.trim()}`);
                            }
                            PdfOperations.ensureMimeType(binary, ['application/pdf']);
                            return Buffer.from(binary.data, 'base64');
                        }));
                        result = await PdfOperations.mergePDFs(pdfBuffers);
                        break;
                    }
                    case Operation.ExtractPages: {
                        const pdfBinaryName = ((_m = binaryFields.pdfBinaryName) === null || _m === void 0 ? void 0 : _m.pdfBinaryName) || 'output';
                        const pages = (_o = options.pageOptions) === null || _o === void 0 ? void 0 : _o.pages;
                        console.log(`Processing ExtractPages with PDF: ${pdfBinaryName}, Pages: ${pages}`);
                        if (!pages) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Les pages à extraire sont requises');
                        }
                        const pdfBinary = (_p = items[i].binary) === null || _p === void 0 ? void 0 : _p[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        result = await PdfOperations.extractPages(Buffer.from(pdfBinary.data, 'base64'), pages);
                        break;
                    }
                    case Operation.Reorder: {
                        const pdfBinaryName = ((_q = binaryFields.pdfBinaryName) === null || _q === void 0 ? void 0 : _q.pdfBinaryName) || 'output';
                        const newPageOrder = this.getNodeParameter('newPageOrder', i);
                        console.log(`Processing Reorder with PDF: ${pdfBinaryName}, New Order: ${newPageOrder}`);
                        if (!newPageOrder) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Le nouvel ordre des pages est requis');
                        }
                        const pdfBinary = (_r = items[i].binary) === null || _r === void 0 ? void 0 : _r[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        result = await PdfOperations.reorderPages(Buffer.from(pdfBinary.data, 'base64'), newPageOrder);
                        break;
                    }
                    case Operation.Rotate: {
                        const pdfBinaryName = ((_s = binaryFields.pdfBinaryName) === null || _s === void 0 ? void 0 : _s.pdfBinaryName) || 'output';
                        const pages = (_t = options.pageOptions) === null || _t === void 0 ? void 0 : _t.pages;
                        const rotationAngle = this.getNodeParameter('rotationAngle', i);
                        console.log(`Processing Rotate with PDF: ${pdfBinaryName}, Pages: ${pages}, Angle: ${rotationAngle}`);
                        if (!pages) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Les pages à rotation sont requises');
                        }
                        const pdfBinary = (_u = items[i].binary) === null || _u === void 0 ? void 0 : _u[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        result = await PdfOperations.rotatePages(Buffer.from(pdfBinary.data, 'base64'), pages, rotationAngle);
                        break;
                    }
                    case Operation.Split: {
                        const pdfBinaryName = ((_v = binaryFields.pdfBinaryName) === null || _v === void 0 ? void 0 : _v.pdfBinaryName) || 'output';
                        const pages = (_w = options.pageOptions) === null || _w === void 0 ? void 0 : _w.pages;
                        console.log(`Processing Split with PDF: ${pdfBinaryName}, Pages: ${pages}`);
                        if (!pages) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Les pages à extraire sont requises');
                        }
                        const pdfBinary = (_x = items[i].binary) === null || _x === void 0 ? void 0 : _x[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        result = await PdfOperations.splitPDF(Buffer.from(pdfBinary.data, 'base64'), pages);
                        break;
                    }
                    case Operation.Metadata: {
                        const pdfBinaryName = ((_y = binaryFields.pdfBinaryName) === null || _y === void 0 ? void 0 : _y.pdfBinaryName) || 'output';
                        const pdfBinary = (_z = items[i].binary) === null || _z === void 0 ? void 0 : _z[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        console.log(`Processing Metadata with PDF: ${pdfBinaryName}`);
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        const metadata = await PdfOperations.readMetadata(Buffer.from(pdfBinary.data, 'base64'));
                        returnData.push([{
                                json: metadata,
                            }]);
                        continue;
                    }
                    case Operation.ExtractText: {
                        const pdfBinaryName = ((_0 = binaryFields.pdfBinaryName) === null || _0 === void 0 ? void 0 : _0.pdfBinaryName) || 'output';
                        const pdfBinary = (_1 = items[i].binary) === null || _1 === void 0 ? void 0 : _1[pdfBinaryName];
                        if (!pdfBinary) {
                            throw new Error(`No binary data found for ${pdfBinaryName}`);
                        }
                        PdfOperations.ensureMimeType(pdfBinary, ['application/pdf']);
                        const text = await PdfOperations.extractText(Buffer.from(pdfBinary.data, 'base64'));
                        returnData.push([{
                                json: {
                                    text,
                                },
                            }]);
                        break;
                    }
                    default:
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Opération non supportée: ${operation}`);
                }
                if (result) {
                    console.log(`Operation ${operation} completed successfully`);
                    returnData.push([{
                            json: {},
                            binary: {
                                [pdfBinaryName]: {
                                    data: result.toString('base64'),
                                    fileName: `${pdfBinaryName}.pdf`,
                                    mimeType: 'application/pdf',
                                },
                            },
                        }]);
                }
            }
            catch (error) {
                console.error(`Error in operation: ${error.message}`);
                throw error;
            }
        }
        return returnData;
    }
    getDescription() {
        return `# PDF Tools Node

Ce nœud permet d'effectuer diverses opérations sur les fichiers PDF.

## Opérations disponibles

### Add Image
Ajoute une image à un PDF existant.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF
- **Image Binary Field**: Nom du champ binaire contenant l'image (PNG ou JPEG)
- **Pages**: Pages cibles (ex: "1", "1,3-5", "all")

### Add Watermark
Ajoute un filigrane textuel au PDF.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF
- **Watermark Text**: Texte du filigrane
- **Pages**: Pages cibles (ex: "1", "1,3-5", "all")

### Delete Pages
Supprime des pages du PDF.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF
- **Pages**: Pages à supprimer (ex: "1", "1,3-5", "all")

### Extract Pages
Extrait des pages spécifiques dans un nouveau PDF.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF
- **Pages**: Pages à extraire (ex: "1", "1,3-5", "all")

### Merge PDFs
Fusionne plusieurs PDFs en un seul.
- **PDF Binary Field Names**: Liste des noms de champs binaires contenant les PDFs à fusionner (séparés par des virgules)

### Read Metadata
Lit les métadonnées d'un PDF.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF

### Reorder Pages
Réorganise les pages d'un PDF.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF
- **Pages**: Nouvel ordre des pages (ex: "3,1,2")

### Rotate Pages
Fait pivoter des pages du PDF.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF
- **Pages**: Pages à faire pivoter (ex: "1", "1,3-5", "all")
- **Rotation Angle**: Angle de rotation (90, 180, 270)

### Split PDF
Divise un PDF en plusieurs fichiers.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF
- **Pages**: Pages à extraire (ex: "1", "1,3-5", "all")

### Extract Text
Extrait le texte d'un PDF.
- **PDF Binary Field**: Nom du champ binaire contenant le PDF

## Formats supportés

- PDF: application/pdf
- Images: image/png, image/jpeg
`;
    }
}
exports.PdfTools = PdfTools;
//# sourceMappingURL=PdfTools.node.js.map